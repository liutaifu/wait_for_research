1、中断中为何不能使用信号量？
  答： 信号量会导致睡眠。
2、中断上下为何不能睡眠？
  中断发生以后，CPU跳到内核设置好的中断处理代码中去，由这部分内核代码来处理中断。这个处理过程中的上下文就是中断上下文。
为什么可能导致睡眠的函数都不能在中断上下文中使用呢？ 首先睡眠的含义是将进程置于“睡眠”状态，在这个状态的进程不能被调度执行。
然后，在一定的时机，这个进程可能会被重新置为“运行”状态，从而可能被调度执行。 可见，“睡眠”与“运行”是针对进程而言的，代表进程
的task_struct结构记录着进程的状态。内核中的“调度器”通过task_struct对进程进行调度。但是，中断上下文却不是一个进程，它并不
存在task_struct，所以它是不可调度的。所以，在中断上下文就不能睡眠。那么，中断上下文为什么不存在对应的task_struct结构呢？
中断的产生是很频繁的（至少每毫秒（看配置，可能10毫秒或其他值）会产生一个时钟中断），并且中断处理过程会很快。如果为中断上下文
维护一个对应的task_struct结构，那么这个结构频繁地分配、回收、并且影响调度器的管理，这样会对整个系统的吞吐量有所影响。但是在
某些追求实时性的嵌入式linux中，中断也可能被赋予task_struct结构。这是为了避免大量中断不断的嵌套，导致一段时间内CPU总是运行在
中断上下文，使得某些优先级非常高的进程得不到运行。这种做法能够提高系统的实时性，但是代价中吞吐量的降低.

liunx六大进程间通信方式
 管道，
     它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
     它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
     它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
 消息队列，
     消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
     消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
     消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。
 共享内存，
     共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
     因为多个进程可以同时操作，所以需要进行同步。
     信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
 信号量，
     信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
     信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
     每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
     支持信号量组。
 socket，
 文件锁
 
 
 Linux0.11内核--几种地址(逻辑地址、线性地址、物理地址)的含义
      1.程序（进程）的虚拟地址和逻辑地址
      2.CPU的线性地址
      3.实际物理内存地址
      线性地址：是CPU所能寻址的空间或者范围。
      物理地址：是机器中实际的内存地址。换言之，是机器中的内存容量范围。
      逻辑地址：是对程序而言的。一般以Seg:Offset来表示。
      因此，若要确实比较三者的话，应有以下关系：线性地址大于等于物理地址(PS:但二者的地址空间是一样的)，
      而逻辑地址大于线性地址。逻辑地址通过段表变换成线性地址，此时如果并未开启分页机制的情况下，逻辑地
      址直接转换成CPU所能寻址的空间。若已开启则通过页表完成线性地址到物理地址的变换。
      三者最准确的关系是：逻辑地址通过线性地址完成物理地址的映射，线性地址在三者之中完全是充当"桥"的作用。
 
 
 kmalloc，vmalloc
      kmalloc和vmalloc是分配的是内核的内存
      kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续,
      kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大
      内存只有在要被DMA访问的时候才需要物理上连续
      vmalloc比kmalloc要慢

linux 中断处理 tasklet workqueue
      软中断、tasklet和工作队列并不是Linux内核中一直存在的机制，而是由更早版本的内核中的“下半部”（bottom half）
      演变而来。下半部的机制实际上包括五种，但2.6版本的内核中，下半部和任务队列的函数都消失了，只剩下了前三者。
      本文重点在于介绍这三者之间的关系。
      
      上半部指的是中断处理程序，下半部则指的是一些虽然与中断有相关性但是可以延后执行的任务。举个例子：在网络传输中，
      网卡接收到数据包这个事件不一定需要马上被处理，适合用下半部去实现；但是用户敲击键盘这样的事件就必须马上被响应，
      应该用中断实现。
      两者的主要区别在于：中断不能被相同类型的中断打断，而下半部依然可以被中断打断；中断对于时间非常敏感，而下半部
      基本上都是一些可以延迟的工作。由于二者的这种区别，所以对于一个工作是放在上半部还是放在下半部去执行，可以参考
      下面四条：
            a）如果一个任务对时间非常敏感，将其放在中断处理程序中执行。
            b）如果一个任务和硬件相关，将其放在中断处理程序中执行。
            c）如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。
            d）其他所有任务，考虑放在下半部去执行。
      由于软中断必须使用可重入函数，这就导致设计上的复杂度变高，作为设备驱动程序的开发者来说，增加了负担。而如果某种
      应用并不需要在多个CPU上并行执行，那么软中断其实是没有必要的。因此诞生了弥补以上两个要求的tasklet。它具有以下特性：
           a）一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。
           b）多个不同类型的tasklet可以并行在多个CPU上。
           c）软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。
      tasklet是在两种软中断类型的基础上实现的，但是由于其特殊的实现机制，所以具有了这样不同于软中断的特性。而由于这种
      特性，所以降低了设备驱动程序开发者的负担，因此如果不需要软中断的并行特性，tasklet就是最好的选择。

      tasklet中不允许休眠，而workqueue允许。tasklet调用时为中断上下文，workque为进程上下文（仅有内核代码）。
      
      
IIC 模拟实现I2C
      https://blog.csdn.net/shaguahaha/article/details/70766665
      
      I2C和SPI的区别  http://m.elecfans.com/article/574049.html
